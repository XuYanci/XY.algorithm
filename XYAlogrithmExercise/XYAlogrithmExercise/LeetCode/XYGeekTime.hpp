//
//  XYGeekTime.hpp
//  XYAlogrithmExercise
//
//  Created by Yanci Xu on 2020/12/10.
//  Copyright © 2020 Yanci. All rights reserved.
//

#ifndef XYGeekTime_hpp
#define XYGeekTime_hpp

#include <stdio.h>

/// 存放极客时间思考题目
class XYGeekTime {
    //现在你有 10 个接口访问日志文件，每个日志文件大小约 300MB，每个文件里的日志都是按照时间戳从小到大排序的。你希望将这 10 个较小的日志文件，合并为 1 个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有 1GB，你有什么好的解决思路，能“快速”地将这 10 个日志文件合并吗？
    
    /// 每个文件占用存储空间300MB,有序；
    /// 最大可用内存空间1GB
    /// 最大并行访问 10
    
    /// 解决方式： 归并排序中的治理（因为已经分了），治的时候写入磁盘文件，尽量利用最大内存空间
    /// 每次读取10个日志文件，每次读取 50M ，这样也就有500M内存占用，因为归并排序不是原地排序，需要额外O(n)也就是500M内存，这样也就用了1G，然后治的时候，通过写文件的方式存储起结果处理已排序部分，保证内存不爆，这个有点类似于换页操作，如果已经处理完50M则继续接口请求
    /// 也就是假设有两个超大文件各300M，因为归并排序里面的治是两个有序比较，我们只需要将已比较部分写入磁盘就可以了。只是要尽可能利用内存空间
    
    void alogrithm1();
    
};

#endif /* XYGeekTime_hpp */
